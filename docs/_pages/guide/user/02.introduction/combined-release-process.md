---
title: Combined Release Process
layout: single
toc: true
permalink: /guide/user/introduction/combined-release-process/
---

In a simplistic way the release process is atomic and happens at the end of the overall build process, meaning that the commit history can be inspected to infer values like the version number to release, apply a tag to the repository and publish to remote platforms.

Real world, on the other hand, is slightly different because most of the times you need the inferred values like the current version number in order to run other build tasks. For example you may need the version number to name your artifacts, render the documentation, send notifications and so on.

This means that the release process needs to be more granular to meet the needs of real world build processes and this is where most of the release tools out there fall short and where Nyx can make a difference.

Nyx offer you fine control on its tasks by running them within specific [commands]({{ site.baseurl }}{% link _pages/guide/user/02.introduction/how-nyx-works.md %}). Each commnand runs a subset of tasks but also makes sure that when running a command, its required tasks dependencies are executed first so you don't need to worry about the sequence you invoke them with.

Let's assume you have a typical scenario in which you need to:

1. infer the new version number based on the commit hostory
2. build your artifacts, documentation etc
3. tag (and optionally push) the Git repository
4. publish the release

Building the artifacts is out of scope for Nyx but all other tasks can be taken care of automatically.

To do the above, you run the [Infer]({{ site.baseurl }}{% link _pages/guide/user/02.introduction/how-nyx-works.md %}#infer) command first to get a new version number. At this time Nyx doesn't apply any change to your repository nor publishes anything, it just reads the commit history to produce a new version number which is consistent with the commit history and the configuration. The details on how you can get the generated version number depend on the means you use Nyx and are detailed in the next sections.

Once *Infer* gave you the version number you can proceed with your own build tasks and, once complete you can run Nyx [Publish]({{ site.baseurl }}{% link _pages/guide/user/02.introduction/how-nyx-works.md %}#publish) to complete the release process. The actual actions that will execute depend on the configuration you give Nyx so it may do nothing or [Make]({{ site.baseurl }}{% link _pages/guide/user/02.introduction/how-nyx-works.md %}#make) artifacts like the [changelog]({{ site.baseurl }}{% link _pages/guide/user/03.configuration-reference/changelog.md %}), [tag and push]({{ site.baseurl }}{% link _pages/guide/user/02.introduction/how-nyx-works.md %}#mark) Git changes to remote repositories and [Publish]({{ site.baseurl }}{% link _pages/guide/user/02.introduction/how-nyx-works.md %}#publish) the release to remote services.

## Using the command line or the Docker image

When running Nyx in separate stages you need to [enable]({{ site.baseurl }}{% link _pages/guide/user/03.configuration-reference/global-options.md %}#state-file) writing the [state file]({{ site.baseurl }}{% link _pages/guide/user/05.state-reference/index.md %}) and [resuming]({{ site.baseurl }}{% link _pages/guide/user/03.configuration-reference/global-options.md %}#resume) from where the process was left. Then you can run Nyx at separate stages like:

```bash
$ nyx --state-file=nyx-state.json --resume infer
[run your build tasks here to create artifacts, docs etc]
$ nyx --state-file=nyx-state.json --resume publish
```

The version generated by the [Infer]({{ site.baseurl }}{% link _pages/guide/user/02.introduction/how-nyx-works.md %}#infer) command is displayed on the console but in case you need a structured way to fetch it you can [enable]({{ site.baseurl }}{% link _pages/guide/user/03.configuration-reference/global-options.md %}#state-file) writing the [state file]({{ site.baseurl }}{% link _pages/guide/user/05.state-reference/index.md %}) and get the [`version`]({{ site.baseurl }}{% link _pages/guide/user/05.state-reference/global-attributes.md %}#version) attribute. Within the state file you can also find plenty of other structured information about the release process.

For the sake of this page, using the Docker image makes no difference as you just need to pass the same command line arguments to Nyx.

## Using the Gradle plugin

Running Nyx at separate stages is easy from Gradle as you can run [tasks]({{ site.baseurl }}{% link _pages/guide/user/02.introduction/usage.md %}#core-tasks) explicitly or by means of dependencies for your own custom tasks to craft your build process.

In case your build process needs multiple, separate Gradle runs to complete, you also need to [enable]({{ site.baseurl }}{% link _pages/guide/user/03.configuration-reference/global-options.md %}#state-file) writing the [state file]({{ site.baseurl }}{% link _pages/guide/user/05.state-reference/index.md %}) and [resuming]({{ site.baseurl }}{% link _pages/guide/user/03.configuration-reference/global-options.md %}#resume) from where the process was left

The version generated by the [Infer]({{ site.baseurl }}{% link _pages/guide/user/02.introduction/how-nyx-works.md %}#infer) command is set as the [Gradle's standard `version` project property](https://docs.gradle.org/current/userguide/writing_build_scripts.html#sec:standard_project_properties) as extensively documented in [Using the Gradle plugin]({{ site.baseurl }}{% link _pages/guide/user/02.introduction/usage.md %}#using-the-gradle-plugin). All other insights can be accessed through the [`nyxState`]({{ site.baseurl }}{% link _pages/guide/user/02.introduction/usage.md %}#accessing-the-nyx-state-extra-project-property-from-build-scripts) property.
